from qgis.PyQt.QtCore import QCoreApplicationfrom qgis.core import QgsProcessingAlgorithm, QgsProcessingParameterRasterLayer, QgsProcessingParameterFileDestination, QgsProcessingParameterBoolean, QgsProcessingParameterNumberfrom landspy import DEM, Flow, Grid, Networkfrom qgis import processingclass CreateNetwork(QgsProcessingAlgorithm):    # Constants used to refer to parameters and outputs They will be    # used when calling the algorithm from another algorithm, or when    # calling from the QGIS console.    INPUT_FD = 'INPUT_FD'    THRESHOLD = 'THRESHOLD'    THETAREF = 'THETAREF'    NPOINTS = 'NPOINTS'    GRADIENTS = 'GRADIENTS'    NET = 'NET'     def __init__(self):        super().__init__()    def createInstance(self):        return type(self)()     def name(self):        """        Rerturns the algorithm name, used to identify the algorithm.        Must be unique within each provider and should contain lowercase alphanumeric characters only.        """        return "createNet"         def displayName(self):        """        Returns the translated algorithm name, which should be used for any        user-visible display of the algorithm name.        """        return self.tr("Create Network")         def groupId(self):        """        Returns the unique ID of the group this algorithm belongs to.        """        return "drainage_net_processing"    def group(self):        """        Returns the name of the group this algoritm belongs to.        """        return self.tr("Drainage Network Processing")    def shortHelpString(self):        """        Returns a localised short helper string for the algorithm.         """        texto = """                    This script creates a Network object (*.dat file).                    Flow direction : Input flow direction raster (obtained from landspy).                    Threshold: Threshold (number of cells) to start a channel in the Network.                    Thetaref: m/n coeficient to calculate Chi metrics                    N Points: Number of points to calculate gradients (slope and ksn) in each pixel. Gradients are calculated for each pixel by linear regression using a moving window of size [npoints * 2 + 1] pixels.                     Gradients: Calculate gradients. If gradients are not calculated, the Network object will not have values for ksn or slope.                    Network: Output Network file (*.dat). This file can not be loaded in QGIS, but it will used by others algoritms.                     """        return texto     def tr(self, string):        return QCoreApplication.translate('Processing', string)    def helpUrl(self):        return "https://github.com/geolovic/qgs_landspy"             def initAlgorithm(self, config=None):        """        Here we define the inputs and output of the algorithm, along        with some other properties.        """        self.addParameter(QgsProcessingParameterRasterLayer(self.INPUT_FD,  self.tr("Flow direction")))        self.addParameter(QgsProcessingParameterNumber(self.THRESHOLD, self.tr("Threshold"), type=QgsProcessingParameterNumber.Integer))        self.addParameter(QgsProcessingParameterNumber(self.THETAREF, self.tr("Thetaref"), type=QgsProcessingParameterNumber.Double, defaultValue=0.45, optional=True))        self.addParameter(QgsProcessingParameterNumber(self.NPOINTS, self.tr("N Points"), type=QgsProcessingParameterNumber.Integer, defaultValue=5, optional=True))        self.addParameter(QgsProcessingParameterBoolean(self.GRADIENTS, self.tr("Gradients"), defaultValue=True, optional=True))        self.addParameter(QgsProcessingParameterFileDestination(self.NET, self.tr("Network object")))     def processAlgorithm(self, parameters, context, feedback):        """        Here is where the processing itself takes place.        """        input_fd = self.parameterAsRasterLayer(parameters, self.INPUT_FD, context)        threshold = self.parameterAsInt(parameters, self.THRESHOLD, context)        thetaref = self.parameterAsDouble(parameters, self.THETAREF, context)        npoints = self.parameterAsInt(parameters, self.NPOINTS, context)        gradients = self.parameterAsBool(parameters, self.GRADIENTS, context)        out_net = self.parameterAsString(parameters, self.NET, context)        fd = Flow(input_fd.source())        if threshold == 0:            threshold = int(fd.getNCells() * 0.0025)            feedback.setProgressText("Threshold not valid...")            feedback.setProgressText("Applying a threshold of {} pixels".format(threshold))                net = Network(fd, threshold=threshold, thetaref=thetaref, npoints=npoints, gradients=gradients)        net.save(out_net)        results = {self.NET : out_net }        return results