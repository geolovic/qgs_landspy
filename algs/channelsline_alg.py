from qgis.PyQt.QtCore import QCoreApplicationfrom qgis.core import QgsProcessingAlgorithm, QgsProcessingParameterFile, QgsProcessingParameterFileDestinationfrom qgis.core import QgsProcessingParameterFeatureSource, QgsProcessingParameterField, QgsProcessingfrom landspy import Network, shp_to_channelsimport numpy as npimport osfrom qgis import processingclass ChannelsFromLines(QgsProcessingAlgorithm):    # Constants used to refer to parameters and outputs They will be    # used when calling the algorithm from another algorithm, or when    # calling from the QGIS console.    NET = 'NET'    LINE_SHP = 'LINE_SHP'    OUT_NPY = 'OUT_NPY'    ID_FIELD = 'ID_FIELD'    NAME_FIELD = 'NAME_FIELD'    def __init__(self):        super().__init__()    def createInstance(self):        return type(self)()    def name(self):        """        Rerturns the algorithm name, used to identify the algorithm.        Must be unique within each provider and should contain lowercase alphanumeric characters only.        """        return "channelsFromLines"    def displayName(self):        """        Returns the translated algorithm name, which should be used for any        user-visible display of the algorithm name.        """        return self.tr("Get channels from lines")    def groupId(self):        """        Returns the unique ID of the group this algorithm belongs to.        """        return "geomorphic_indexes"    def group(self):        """        Returns the name of the group this algoritm belongs to.        """        return self.tr("Geomorphic Indexes")    def shortHelpString(self):        """        Returns a localised short helper string for the algorithm.         """        texto = """                    This script get channels from a river (polyline) shapefile                    Channel shapefile : Polyline shapefile with the channels to extract. It is recommended that this shapefile is computed from landspy functions. Multipart features will be discarded.                    Name field [Optional]: Field of the channel shapefile with channels names (labels)                    Output channels: Output channels corresponding to channel shapefile                    """        return texto    def tr(self, string):        return QCoreApplication.translate('Processing', string)    def helpUrl(self):        return "https://github.com/geolovic/qgs_landspy"    def initAlgorithm(self, config=None):        """        Here we define the inputs and output of the algorithm, along        with some other properties.        """        self.addParameter(QgsProcessingParameterFile(self.NET, self.tr("Network (.dat)"), extension="dat"))        self.addParameter(QgsProcessingParameterFeatureSource(self.LINE_SHP, self.tr("Channel shapefile"),                                                              [QgsProcessing.TypeVectorLine]))        self.addParameter(            QgsProcessingParameterField(self.ID_FIELD, self.tr("Id Field"), parentLayerParameterName=self.LINE_SHP,                                        type=QgsProcessingParameterField.Numeric, optional=True))        self.addParameter(            QgsProcessingParameterField(self.NAME_FIELD, self.tr("Name Field"), parentLayerParameterName=self.LINE_SHP,                                        type=QgsProcessingParameterField.String, optional=True))        self.addParameter(            QgsProcessingParameterFileDestination(self.OUT_NPY, self.tr("Output channels"), fileFilter="npy"))    def processAlgorithm(self, parameters, context, feedback):        """        Here is where the processing itself takes place.        """        input_net = self.parameterAsFile(parameters, self.NET, context)        line_shp = self.parameterAsVectorLayer(parameters, self.LINE_SHP, context)        out_npy = self.parameterAsString(parameters, self.OUT_NPY, context)        id_field = self.parameterAsString(parameters, self.ID_FIELD, context)        name_field = self.parameterAsString(parameters, self.NAME_FIELD, context)        if os.path.splitext(out_npy)[1] not in [".npy"]:            out_npy = os.path.splitext(out_npy)[0] + ".npy"        net = Network(input_net)        n_id = line_shp.fields().indexFromName(id_field)        n_name = line_shp.fields().indexFromName(name_field)        canales = []        for n, feat in enumerate(line_shp.getFeatures()):            if feat.hasGeometry():                if n_id >= 0:                    idx = feat[n_id]                else:                    idx = n + 1                if n_name >= 0:                    name = feat[n_name]                else:                    name = str(n)                geom = feat.geometry()                for part in geom.get():                    first_point = part[0]                    last_point = part[-1]                    head = [first_point.x(), first_point.y()]                    mouth = [last_point.x(), last_point.y()]                    canal = net.getChannel(head, mouth, name=name, oid=idx)                    canales.append(canal)        np.save(out_npy, canales, allow_pickle=True)        results = {self.OUT_NPY: out_npy}        return results