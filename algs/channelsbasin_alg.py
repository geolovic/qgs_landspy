from qgis.PyQt.QtCore import QCoreApplicationfrom qgis.core import QgsProcessingAlgorithm, QgsProcessingParameterFile, QgsProcessingParameterRasterLayer, QgsProcessingParameterNumberfrom qgis.core import QgsProcessingParameterFeatureSource, QgsProcessingParameterField, QgsProcessing, QgsProcessingParameterFileDestinationfrom landspy import Network, BNetwork, Gridimport numpy as npimport osfrom qgis import processingclass ChannelsFromBasin(QgsProcessingAlgorithm):    # Constants used to refer to parameters and outputs They will be    # used when calling the algorithm from another algorithm, or when    # calling from the QGIS console.    NET = 'NET'    BASINS = 'BASINS'    BASIN_ID = 'BASIN_ID'    MIN_DIST = 'MIN_DIST'    HEAD_SHP = 'HEAD_SHP'    ID_HEAD = 'ID_HEAD'    OUT_NPY = 'OUT_NPY'     def __init__(self):        super().__init__()    def createInstance(self):        return type(self)()     def name(self):        """        Rerturns the algorithm name, used to identify the algorithm.        Must be unique within each provider and should contain lowercase alphanumeric characters only.        """        return "channelsFromBasin"         def displayName(self):        """        Returns the translated algorithm name, which should be used for any        user-visible display of the algorithm name.        """        return self.tr("Get channels from basin")         def groupId(self):        """        Returns the unique ID of the group this algorithm belongs to.        """        return "geomorphic_indexes"    def group(self):        """        Returns the name of the group this algoritm belongs to.        """        return self.tr("Geomorphic Indexes")    def shortHelpString(self):        """        Returns a localised short helper string for the algorithm.         """        texto = """                    This script get all the channels (.npy file) for a single drainage basin.                     Network : Network object (*.dat file)                    Basins: Raster with the drainage basins.                     Basin Id: Id of the basin in the basins raster.                    Channel minimum length [Optional]: Channel minimum length to consider. Channels with lower lengtsh will be discarded.                    Heads [Optional]: Point shapefile wiht the basin heads. Points in this shapefile will be processed before any other head of the Network.                    Heads id[Optional]: Field of the heads shapefile with the orders. Lower id number will process first.                     Output channels: Output channels. All channels will be returned into a *.npy file (numpy array).                    """        return texto     def tr(self, string):        return QCoreApplication.translate('Processing', string)    def helpUrl(self):        return "https://github.com/geolovic/qgs_landspy"             def initAlgorithm(self, config=None):        """        Here we define the inputs and output of the algorithm, along        with some other properties.        """        self.addParameter(QgsProcessingParameterFile(self.NET, self.tr("Network (.dat)"), extension="dat"))        self.addParameter(QgsProcessingParameterRasterLayer(self.BASINS, self.tr("Basins")))        self.addParameter(QgsProcessingParameterNumber(self.BASIN_ID, self.tr("Basin Id"), QgsProcessingParameterNumber.Integer, 1))        self.addParameter(QgsProcessingParameterNumber(self.MIN_DIST, self.tr("Channel minimum length"), QgsProcessingParameterNumber.Double, optional=True))        self.addParameter(QgsProcessingParameterFeatureSource(self.HEAD_SHP, self.tr("Heads"), [QgsProcessing.TypeVectorPoint], optional=True))        self.addParameter(QgsProcessingParameterField(self.ID_HEAD, self.tr("Heads id"), parentLayerParameterName=self.HEAD_SHP, type=QgsProcessingParameterField.Numeric, optional=True))        self.addParameter(QgsProcessingParameterFileDestination(self.OUT_NPY, self.tr("Output channels"), fileFilter="Numpy file (*.npy)"))    def processAlgorithm(self, parameters, context, feedback):        """        Here is where the processing itself takes place.        """        input_net = self.parameterAsFile(parameters, self.NET, context)        basin_ras = self.parameterAsRasterLayer(parameters, self.BASINS, context)        basin_id = self.parameterAsInt(parameters, self.BASIN_ID, context)        heads_id = self.parameterAsString(parameters, self.ID_HEAD, context)        mindist = self.parameterAsDouble(parameters, self.MIN_DIST, context)        heads_shp = self.parameterAsVectorLayer(parameters, self.HEAD_SHP, context)        out_npy = self.parameterAsString(parameters, self.OUT_NPY, context)                # Get Network and Basins        net = Network(input_net)        basins = Grid(basin_ras.source())                # Chek basin_id        if (basin_id not in basins.readArray()) or (basin_id == 0):            feedback.setProgressText("Wrong basin id!!")            return {}                if not mindist:            mindist = 0                # Get heads array        if not heads_shp:            heads = None        else:            field_idx = heads_shp.fields().indexFromName(heads_id)            puntos = []            for n, feat in enumerate(heads_shp.getFeatures()):                if field_idx >= 0:                    idx = feat[field_idx]                else:                    idx = n + 1                pto = feat.geometry().asPoint()                puntos.append([pto.x(), pto.y(), idx])                        heads = np.array(puntos)                    bnet = BNetwork(net, basins, heads, basin_id)        canales = bnet.getChannels("ALL", min_length=mindist)        np.save(out_npy, canales, allow_pickle=True)        results = {self.OUT_NPY:out_npy}        return results